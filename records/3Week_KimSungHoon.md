# 3Week_KimSungHoon.md

## Title: [3Week] 김성훈

### 미션 요구사항 분석 & 체크리스트

#### 필수과제_목표

- [x] 네이버 클라우드 플랫폼을 통한 배포(도메인 없이, IP로 접속)
  - [x] http:// ( 공인 IP ) 형태로 접속이 가능
- [x] 호감표시, 호감변경 후, 개별 호감 표시 건에 대해서 3시간 동안은 호감 취소와 변경이 불가능 하도록 작업
  - [x] 호감표시를 한 후 3시간 동안 취소나 변경이 불가능
  - [x] 호감사유 변경을 한 후 3시간 동안 취소나 변경이 불가능

<br/>

#### 선택과제_목표
- [x] 알림 기능 구현
  - [x] 호감 표시를 받았거나, 본인에 대한 호감 사유가 변경된 경우에 알림 페이지에서 확인이 가능하도록
  - [x] 각각의 알림은 생성시의 **readDate** 가 **null** 이고, 알림을 읽은 시점에 **현재날짜**로 세팅되어야 함.

<br/>

---

### 3주차 미션 요약

#### - 네이버 클라우드 플랫폼의 서버를 개설하고, 프로젝트 파일을 통한 도커 이미지 생성, 빌드, 실행
#### - 호감표시, 변경시에 3시간 쿨타임 적용
#### - 호감 표시를 받았거나 나에 대한 호감이 변경된 내역에 대한 알림 서비스 구현

---

### [접근 방법]

#### 필수 미션

### 1. 네이버 클라우드 플랫폼을 통한 배포

1. **사전 작업** <br/>
   네이버 클라우드 플랫폼 회원가입 후, CentOS 기반의 서버 개설, ACG(네트워크 관리 서비스) 설정,
   포트포워딩을 통한 접속용 포트 설정, 공인 IP 할당을 수행하였다.

<br/>

2. **SSH(Secure Shell)을 통한 접속과 기본 설치** <br/>
   ssh -p(서버 접속용 포트) (서버 접속용 공인 IP) 를 통해 서버에 접속한 후,
   yum 다운로드 및 업데이트, 도커 설치 및 시작, 활성화, MariaDB를 설치한 후 배포용
   데이터베이스인 gram__prod DB를 생성, git 설치, java17(jdk-17.0.2)등의 작업을 수행하였다.

<br/>

3. **GIT을 통한 소스코드 클론 및 빌드** <br/>
   git을 사용하여 깃허브 Repository를 클론하여 내용을 받아왔고, 
   application.yml(secret, prod, default 등)의 파일들에 대해 OAuth2.0 관련 내용을 기입하거나, 
   MariaDB의 정보(username, password) 등의 내용을 기입하는 드의 작업을 수행하였고,
   gradlew의 권한을 744로 변경함으로써 빌드를 가능하게 수정한 후, 빌드를 진행하였다. (정상작동)

<br/>

4. **Dockerfile 생성** <br/>
   build/libs 디렉토리에 들어있는 gramgram-0.0.1-SNAPSHOT.jar(gramgram 어플리케이션 스냅샷) 을
   경로로 지정하고, Docker 컨테이너 내부에서 8080 포트를 열어서 해당 포트를 통해 외부에서 컨테이너
   내부의 어플리케이션에 접근할 수 있으며, openjdk:17-jdk-alpine 기반으로 어플리케이션을 실행할 수 있도록
   하며, spring.prifiles.active의 속성을 prod(배포용 프로필) 로 실행할 수 있도록 Dockerfile을 생성하였다.

<br/>

5. **Dockerfile 을 통한 이미지 생성 후 실행** <br/>
   4번의 내용이 적혀있는 Dockerfile을 통해 gram 이라는 이미지를 docker built -t 명령어를 통해 생성하였고,
   컨테이너의 이름을 gram_1 으로 설정하여 호스트의 80포트를 컨테이너의 8080 포트로 매핑할 수 있도록 설정하여
   도커 이미지를 실행한 결과, http://(공인 IP) 로 접속이 가능해진 것을 확인할 수 있었다.

<br/>

---

### 2. 호감표시/변경시에 추가적인 삭제/변경에 대해 3시간 쿨타임 적용

1. **사전 작업** <br/>
    2주차 미션에서 호감표시 최대 명 수를 10명으로 지정했던 것 처럼, application.yml에서
    custom.likeablePerson.modifyCoolDown의 값을 {60 * 60 * 3} 으로 선언해 주었고, 해당 값을
    AppConfig 클래스에서 참조할수 있도록 하였다. **다만, 해당 값은 "쿨타임이 3시간 이다" 라는 단순한 의미**이고,
    실제로 쿨타임이 적용될 때에는 ("현재 시각 + 쿨타임 3시간") 과 같이 선언해 주어야 하기 때문에, 
    genLikeablePersonModifyUnlockDate() 라는 메서드를 생성하여 해당 내용이 사용되도록 하였다.

<br/>

2. **생성시 쿨타임 함께 저장** <br/>
    LikeablePerson 엔티티가 생성될 때 쿨타임 또한 생성될 수 있도록 엔티티에 modifyUnlockDate(쿨타임 해제 시각)
    이라는 의미의 변수를 추가하였고, 호감 내용이 생성될 때(like) 마다 수행되는 빌더 패턴의 객체 생성 관련 코드에
    ``.modifyUnlockDate(AppConfig.genLikeablePersonModifyUnlockDate())`` 과 같은 내용을 추가함으로써 생성시마다
    쿨타임이 적용될 수 있도록 하였다.

<br/>

3. **호감사유 변경 시 쿨타임 갱신**<br/>
    호감사유 변경을 수행하는 updateAttractionTypeCode 메서드에서 호감사유 변경이 수행될 때 호감사유 변경과 함께
    쿨타임의 갱신 또한 "변경되고 있는 현재 시각 + 3시간" 과 같이 새로운 시각으로 갱신되도록 하였다.

<br/>

4. **쿨타임 종료까지 남은 시간은?**<br/>
    쿨타임 종료시까지 얼마만큼의 시간이 남았는지 알 수 있는 getModifyUnlockDateRemainStrHuman() 이라는 메서드를 구현하여,
    현재 시간에서 쿨타임 해제 시간까지 얼마만큼의 차이가 있는지를 확인할 수 있는 Duration 클래스의 변수를 생성하고,
    Duration.between(nowDate, modifyUnlockDate) 의 값을 대입하여 남은 시간이 얼마만큼인지 알 수 있도록 하였다.
    해당 값의 시각과 분을 long 타입 변수에 대입하여, ("00시간 00분 후") 라는 내용으로 출력될 수 있도록 format 처리하여
    반환할 수 있도록 하였다.

<br/>

5. **쿨타임이 지나기 전에는 삭제나 변경이 불가능**<br/>
    쿨타임이 지나기 전에는 삭제나 변경이 불가능 하도록 해야 하기 때문에, 삭제를 할 수 있는지 확인할 수 있도록 구현되어 있던
    메서드인 canCancel 메서드와 canModifyLike 메서드에 ``if(LocalDateTime.now().isBefore(modifyUnlockDate))`` 과 같은
    검사 로직을 추가하여 쿨타임 시각을 지나지 않았다면, 
    ``"쿨타임 해제 시각 : (15시 30분)으로, 아직 (02시간 30분 후) 부터 가능합니다.`` 와 같은
    문구가 출력될 수 있도록 하였다.

<br/>

---

<br/>

#### 선택 미션

### 알림 기능 구현

1. **사전 설정 내용** <br/>
    현재 Notification 엔티티에는 BaseEntity에서 상속받은 내용(id, createdate, modifydate)과 readDate 등을
    포함한 여러가지 내용들이 선언되어 있다. 컨트롤러에서는 /usr/notificaion/list URL이 입력되면 인스타그램 계정이
    연동 되었는지를 확인하고, jpaRepository 를 통해 얻은 메서드인 findByToInstaMember 메서드를 통해
    나에게 필요한 알림들(나에 대한 변동만 받아야 하기 때문)만 모아 model에 추가하여 보내주고 있는 상황이다.

<br/>

2. **프론트 단의 처리** <br/>
    타임리프 문법을 통해 model에 추가된 내용이 없다면(내게 온 알림이 존재하지 않는다면) 최근에 받은 알림이 없습니다.
    라는 문구만 출력하도록 하고, 만약 존재한다면 해당 내용의 값들이 하나씩 최신 순서로(추가된 역순으로) 보여지도록 하였다.
   
<br/>

3. **알림의 생성** <br/>
    알림이 생성되는 경우는 1. 새로운 호감 내용이 생성되었을 때(like), 2. 기존의 호감 내용이 변경되엇을 떄(modify)이므로,
    해당 내용이 수행될 때 마다 새로운 알림이 생성될 수 있도록 하였다. notificationService에 createNotification() 메서드와
    modifyNotification() 메서드를 선언하였고, 각 메서드는 알림 생성에 필요한 정보를 받아올 수 있도록 LikeablePerson 객체를
    매개변수를받으며, 호감 변경시에는 이전의 호감 코드를 알 수 있도록 추가적으로 oldAttractiveTypeCode를 매개변수로 받는다.
    해당 내용이 들어오면, 빌더 패턴을 사용하여 Notificaion 객체가 생성되고, save하여 저장될 수 있도록 하였다.

<br/>

4. **알림의 호출** <br/>
    알림이 생성된 후, 프론트 단에서 확인을 할때 앞서 언급했듯이 model 객체에 알림 리스트를 넣어주기 전에 Collections.reverse()
    메서드를 통해 최신 알림이 상단에 오도록 역순으로 전송하도록 하였고, 현재 우리는 알림을 읽을 것 이므로 이번에 읽게 된 알림
    들 중에서 읽은 시각이 표시되지 않은(아직 읽지 않은 알림)들에 대해 readDate 값을 현재 시각으로 갱신해줄 수 있도록
    updateReadDate(Member member) 라는 메서드를 구현하였다. 해당 메서드에너는 jpaRepository를 통해 얻은 
    findByToInstaMemberAndReadDateIsNull(member.getInstaMember()) 라는 메서드를 통해 알림 목록 중에서
    현재 로그인한 회원의 알림인데, readDate가 null인 상태(읽지 않은)의 알림들만 가지고 와서 해당 내용을 현재 시각으로 세팅해주는
    역할을 하도록 하였다.

<br/>

5. **변수의 toString, Format** </br>
    호감코드가 몇번인지에 따라 번호에 맞는 호감 내용을 String 형태로 리턴해주는 getAttractiveTypeDisplayName 메서드와
    알림이 언제 생성되었는지를 알려줄 수 있도록 하는 getDateForDisplay 메서드를 구현하여, 타임리프 문법으로 해당 메서드를
    사용하여 내용들이 보다 보기 좋게 출력되도록 하였다.
    프론트에서 출력되는 내용은 다음과 같다.

    ```
    알림 
   (05월 03일 14시 30분)
   내용
   (인스타유저1) 가 당신의 호감 사유를 (외모) 에서 (성격) 으로 변경하였습니다.
   ---
   알림
   (05월 03일 14시 00분)
   내용
   (인스타유저1) 가 당신을 (외모) 때문에 좋아합니다.
    ```
   
---

### [특이 사항]

#### 필수 미션

추가구현
- 

느낀점
- 

<br/>

#### 선택 미션

느낀점
- 
